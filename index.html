<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Visualizer</title>
    <style>
        /* Embedded CSS */
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #74ebd5, #acb6e5);
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            max-width: 600px;
            margin: auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .instructions, .usage, .purpose {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f4f7;
            border: 1px solid #3498db;
            border-radius: 5px;
        }

        .instructions p, .usage p, .purpose p {
            line-height: 1.5;
        }

        textarea {
            width: 100%;
            height: 100px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            font-size: 18px;
            cursor: pointer;
        }

        button:hover {
            background-color: #2980b9;
        }

        .examples {
            margin-top: 20px;
        }

        .example {
            padding: 10px;
            border: 1px solid #3498db;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .error {
            color: #e74c3c;
            font-weight: bold;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sorting Algorithm Visualizer</h1>
        <div class="instructions">Enter numbers separated by commas (e.g., 1, 2, 3)</div>
        <textarea id="inputNumbers"></textarea>
        <button id="sortButton">Sort</button>
        <div class="usage">
            <h2>How to Use</h2>
            <p>Welcome to the Sorting Algorithm Visualizer! ...</p>
        </div>
        <div class="purpose">
            <h2>What Itâ€™s Used For</h2>
            <p>The Sorting Algorithm Visualizer is a powerful educational tool...</p>
        </div>
        <h2>Examples</h2>
        <div class="examples">
            <div class="example">
                <strong>Input:</strong> <span>[64, 34, 25, 12, 22, 11, 90]</span><br>
                <strong>Sorted Output:</strong> <span class="output"></span>
            </div>
            <div class="example">
                <strong>Input:</strong> <span>[5, 2, 9, 1, 5, 6]</span><br>
                <strong>Sorted Output:</strong> <span class="output"></span>
            </div>
            <div class="example">
                <strong>Input:</strong> <span>[3, 0, 2, 5, -1, 4, 1]</span><br>
                <strong>Sorted Output:</strong> <span class="output"></span>
            </div>
        </div>
        <div class="error" id="errorMessage"></div>
    </div>

    <script>
        // Embedded JavaScript
        function swap(arr, i, j) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }

        function binaryInsert(arr, key, left, right) {
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                if (key < arr[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            return left;
        }

        function insertionSort(arr, left, right) {
            for (let i = left + 1; i <= right; i++) {
                const key = arr[i];
                const position = binaryInsert(arr, key, left, i - 1);
                for (let j = i; j > position; j--) {
                    arr[j] = arr[j - 1];
                }
                arr[position] = key;
            }
        }

        function mergeInPlace(arr, left, mid, right) {
            let start1 = left, start2 = mid + 1;
            if (arr[mid] <= arr[start2]) return;
            while (start1 <= mid && start2 <= right) {
                if (arr[start1] <= arr[start2]) {
                    start1++;
                } else {
                    const value = arr[start2];
                    let index = start2;
                    while (index > start1) {
                        arr[index] = arr[index - 1];
                        index--;
                    }
                    arr[start1] = value;
                    start1++;
                    mid++;
                    start2++;
                }
            }
        }

        function mergeSort(arr, left, right) {
            if (left < right) {
                const mid = Math.floor((left + right) / 2);
                mergeSort(arr, left, mid);
                mergeSort(arr, mid + 1, right);
                mergeInPlace(arr, left, mid, right);
            }
        }

        function analyzeData(arr) {
            let isSorted = true;
            let min = arr[0], max = arr[0];
            let runs = 0, maxRunLength = 1;
            let totalElements = arr.length;

            for (let i = 1; i < totalElements; i++) {
                if (arr[i] < arr[i - 1]) isSorted = false;
                if (arr[i] < arr[i - 1]) {
                    runs++;
                    maxRunLength = Math.max(maxRunLength, runs);
                } else {
                    runs = 0;
                }
                min = Math.min(min, arr[i]);
                max = Math.max(max, arr[i]);
            }

            const range = max - min;
            return { isSorted, min, max, maxRunLength, range, totalElements };
        }

        function predictStrategy(analysis, historicalData) {
            if (analysis.isSorted) return 'insertion';
            if (analysis.maxRunLength > 5) return 'insertion';
            if (analysis.range < 10) return 'merge';
            const averageTime = historicalData[analysis.totalElements] || 0;
            if (averageTime < 50) return 'quick';
            return 'bubble';
        }

        function adaptiveBidirectionalBubbleSort(arr, historicalData) {
            const n = arr.length;
            if (n <= 1) return arr;

            let start = 0, end = n - 1;
            const insertionThreshold = Math.max(10, Math.floor(n / 20));
            const mergeSortThreshold = 50;

            const analysis = analyzeData(arr);
            const strategy = predictStrategy(analysis, historicalData);
            if (analysis.isSorted) return arr;

            while (start < end) {
                let swapped = false;
                let lastSwappedIndex = end;

                if (strategy === 'insertion') {
                    insertionSort(arr, start, end);
                    break;
                } else if (strategy === 'merge') {
                    mergeSort(arr, start, end);
                    break;
                }

                for (let j = start; j < lastSwappedIndex; j++) {
                    if (arr[j] > arr[j + 1]) {
                        swap(arr, j, j + 1);
                        swapped = true;
                        lastSwappedIndex = j;
                    }
                }
                end = lastSwappedIndex;

                for (let j = end; j > start; j--) {
                    if (arr[j] < arr[j - 1]) {
                        swap(arr, j, j - 1);
                        swapped = true;
                    }
                }
                start++;

                if (!swapped) break;

                const currentLength = end - start;

                if (currentLength < insertionThreshold) {
                    insertionSort(arr, start, end);
                    break;
                } else if (currentLength > mergeSortThreshold) {
                    mergeSort(arr, start, end);
                    break;
                }
            }

            historicalData[n] = (historicalData[n] || 0) + (n * 10);
            return arr;
        }

        function displaySortedArray() {
            const input = document.getElementById('inputNumbers').value;
            const errorMessage = document.getElementById('errorMessage');
            const outputs = document.querySelectorAll('.output');

            // Clear previous error messages and outputs
            errorMessage.textContent = '';
            outputs.forEach(output => output.textContent = '');

            // Parse the input
            const arr = input.split(',').map(num => parseFloat(num.trim())).filter(num => !isNaN(num));

            if (arr.length === 0) {
                errorMessage.textContent = 'Please enter valid numbers separated by commas.';
                return;
            }

            const historicalData = {}; // Initialize historical data for performance tracking
            const sortedArray = adaptiveBidirectionalBubbleSort(arr, historicalData);

            // Display the sorted output
            outputs.forEach((output, index) => {
                if (index < arr.length) {
                    output.textContent = sortedArray[index];
                }
            });
        }

        document.getElementById('sortButton').addEventListener('click', displaySortedArray);
    </script>
</body>
</html>